

# Harry Potter Explorer

## Краткое описание проекта

Я сделал **Harry Potter Explorer** — iOS‑приложение на **SwiftUI (iOS 16+)** для изучения персонажей и факультетов вселенной «Гарри Поттера». Данные берутся не напрямую из внешнего API, а через мой **BFF‑сервер** (Node.js + Express), который проксирует запросы к публичному **HP API** и добавляет пагинацию/поиск/кеш.

Репозиторий содержит две части:
- `server/` — BFF (backend-for-frontend)
- `ios/` — iOS клиент

## Инструкции по установке и запуску

### 1) Запуск сервера (BFF)

Требования: Node.js 18+.

```bash
cd server
npm install
npm run build
npm start
```

ENV переменные (необязательно, есть дефолты):
- `HP_API_BASE` — базовый URL внешнего HP API (по умолчанию `https://hp-api.onrender.com`)
- `PORT` — порт сервера (по умолчанию 3000)

Проверка:
```bash
curl -i http://localhost:3000/health
curl -s "http://localhost:3000/v1/characters?page=1&limit=5" | python3 -m json.tool
```

### 2) Запуск iOS приложения

Требования: Xcode 15+.

1) Открыть проект в Xcode:
- `ios/HarryPotterExplorer/HarryPotterExplorer.xcodeproj`

2) В `ios/.../Config/AppConfig.swift` указан `apiBaseURL` (адрес BFF). Для локального запуска можно указать `http://localhost:3000` (или URL деплоя).

3) Запустить на симуляторе/устройстве.

## Описание процесса проектирования и разработки

1) Сначала я реализовал **BFF**, чтобы выполнить требование ТЗ: *все внешние сервисы вызываются только с серверной части*. На сервере добавил:
- запросы к внешнему HP API,
- кеш списка персонажей в памяти (TTL 10 минут),
- пагинацию и поиск по имени,
- стабильные `id` (из API, либо sha1 от `name|actor|house`).

2) Затем сделал iOS‑клиент:
- базовая навигация через TabView + NavigationStack,
- экраны Houses / Characters / Details,
- избранное (локально),
- Home экран с выбранным персонажем.

Разрабатывал итеративно: сначала «скелет» приложения и контракт API, затем список, потом деталку и UX‑улучшения.

## Уникальные подходы / методологии

- **BFF как прослойка**: клиент не знает про внешний HP API, работает только с моими эндпоинтами `/v1/*`.
- **In-memory кеш на сервере** (TTL 10 минут) для снижения нагрузки и ускорения ответов.
- **Стабильные идентификаторы** для персонажей (sha1), чтобы избранное и навигация работали одинаково между запусками.
- **Placeholder‑аватары**: если у персонажа нет фото, показываю инициалы + детерминированный цвет (по seed), чтобы список выглядел аккуратно.
- **Lottie splash** на старте приложения для лёгкой “магической” атмосферы.

## Компромиссы, принятые во время разработки

- Я держал стек минимальным: без лишних слоёв абстракций и без тяжёлых зависимостей.
- Избранное храню в **UserDefaults**, а не в БД (быстрее и достаточно для тестового).
- Серверный кеш — в памяти (без Redis), потому что это проще и бесплатнее для демонстрации.
- Не делал сложную оффлайн‑синхронизацию и “умные” локальные базы (CoreData/Realm) — это избыточно для объёма тестового.

## Известные ошибки / проблемы

- **Не у всех персонажей есть изображение** в данных HP API — это не баг приложения. Для таких случаев используется placeholder.
- В симуляторе иногда появляются системные логи сети (`nw_connection...`) — на функциональность не влияет.
- При очень быстром скролле SwiftUI может пересоздавать ячейки списка — поэтому важен кеш изображений/placeholder (в проекте это учтено).

## Почему я выбрал этот технический стэк

- **Node.js + Express (BFF)**: максимально быстро поднять сервер, реализовать проксирование, кеш, пагинацию и обработку ошибок без лишней инфраструктуры.
- **SwiftUI + MVVM**: минимальный объём кода, удобная реактивная модель состояния, нативная интеграция с `async/await`.
- **Минимум зависимостей**: быстрее собрать, проще проверять, меньше рисков при деплое/запуске.